{"version":3,"file":"cli.js","sources":["../src/utils/async-observable.ts","../src/parcel/index.ts","../src/utils/cpu.ts","../src/core/task.ts","../src/core/workerFarm.ts","../src/core/index.ts","../src/cli/index.js"],"sourcesContent":["import { Observable } from 'rxjs'\n\nexport default <T>(func: Function): Observable<T> =>\n  Observable.create(observer => {\n    const unsubscribe = func(observer)\n    return async () => (await unsubscribe)?.()\n  })\n","import Parcel from '@parcel/core'\r\n\r\nimport AsyncObservable from '../utils/async-observable.ts'\r\n\r\nexport enum PARCEL_REPORTER_EVENT {\r\n  BUILD_START = 'buildStart',\r\n  BUILD_PROGRESS = 'buildProgress',\r\n  BUILD_SUCCESS = 'buildSuccess',\r\n  BUILD_FAILURE = 'buildFailure',\r\n  LOG = 'log'\r\n}\r\n\r\nexport default (initialParcelOptions) =>\r\n  AsyncObservable(async observer => {\r\n    const parcel = new Parcel({\r\n      entries: ['tests/unit/index_test.ts'],\r\n      targets: {\r\n        test: {\r\n          distDir: '.epk/dist/browser',\r\n          \"browsers\": [\"> 1%\", \"not dead\"]\r\n        }\r\n      },\r\n      sourceMaps: true,\r\n      minify: true,\r\n      scopeHoist: true\r\n    })\r\n    \r\n    const { unsubscribe } = await parcel.watch((err, build) => {\r\n      if (err) observer.throw(err)\r\n      observer.next(build)\r\n    })\r\n\r\n    return () => unsubscribe()\r\n  })\r\n","import os from 'os'\r\nimport childProcess from 'child_process'\r\n\r\n// todo: once top level await gets there, use it\r\n\r\nlet amount\r\n\r\nif (globalThis.window !== undefined) {\r\n  amount = window.navigator.hardwareConcurrency\r\n} else {\r\n  const exec =\r\n    command =>\r\n      childProcess.execSync(command, {encoding: 'utf8'})\r\n  const platform = os.platform()\r\n\r\n  if (platform === 'linux') {\r\n    const output = exec('lscpu -p | egrep -v \"^#\" | sort -u -t, -k 2,4 | wc -l')\r\n    amount = parseInt(output.trim(), 10)\r\n  } else if (platform === 'darwin') {\r\n    const output = exec('sysctl -n hw.physicalcpu_max')\r\n    amount = parseInt(output.trim(), 10)\r\n  } else if (platform === 'windows') {\r\n    const output = exec('WMIC CPU Get NumberOfCores')\r\n    amount = output.split(os.EOL)\r\n      .map(line => parseInt(line))\r\n      .filter(value => !isNaN(value))\r\n      .reduce((sum, number) => sum + number, 0)\r\n  } else {\r\n    const cores = os.cpus().filter(function (cpu, index) {\r\n      const hasHyperthreading = cpu.model.includes('Intel')\r\n      const isOdd = index % 2 === 1\r\n      return !hasHyperthreading || isOdd\r\n    })\r\n    amount = cores.length\r\n  }\r\n}\r\n\r\n\r\n\r\nexport {\r\n  amount as cpuCount\r\n}","import { Observable } from 'rxjs'\r\n\r\nexport enum TASK_TYPE {\r\n  PRE_ANALYZE = 'preAnalyze',\r\n  RUN = 'run',\r\n  ANALYZE = 'analyze'\r\n}\r\n\r\nexport enum TASK_STATUS {\r\n  START = 'start',\r\n  END = 'end',\r\n  CANCEL = 'cancel'\r\n}\r\n\r\nexport interface Task {\r\n  type: TASK_TYPE\r\n  data: any\r\n}\r\n\r\nexport interface TaskMessage {\r\n  type: TASK_TYPE\r\n  status: TASK_STATUS\r\n  data?: any\r\n}\r\n\r\n// export default\r\n//   (task: Task) =>\r\n//     messages =>\r\n//       messages\r\n//       |> \r\n\r\n\r\n// export default (task: Task) =>\r\n//   Observable.create(observer => {\r\n//     let _observer\r\n//     const task = Observable.create<TaskMessage>(observer => {\r\n//       _observer = observer\r\n//       observer.next({ type: TASK_STATUS.START })\r\n//       return () => observer.next({ type: TASK_STATUS.CANCEL })\r\n//     })\r\n//     workerFarm.next(task)\r\n//     return () => _observer.complete()\r\n//   })\r\n","import { Worker } from 'worker_threads'\r\n\r\nimport Logger from '@parcel/logger'\r\nimport { Observable, Subject, fromEvent, ReplaySubject } from 'rxjs'\r\nimport { mergeMap, tap, pluck, map, filter, finalize, shareReplay, publish, withLatestFrom, takeUntil, takeWhile } from 'rxjs/operators'\r\n\r\nimport { cpuCount } from '../utils/cpu.ts'\r\nimport { TaskMessage, TASK_STATUS } from './task.ts'\r\n\r\nexport default () => {\r\n  const idleWorker =\r\n      Array(cpuCount)\r\n      .fill(undefined)\r\n      .map(() => new Worker('./dist/worker.js'))\r\n  const taskSubject = new Subject()\r\n\r\n  const queue =\r\n    taskSubject\r\n    |> mergeMap(\r\n      (task, _, count) => {\r\n        const worker = idleWorker.splice(0, 1)[0]\r\n        const workerMessages = fromEvent(worker, 'message')\r\n        let done = false\r\n        let canceled = false\r\n\r\n        worker.postMessage({ status: TASK_STATUS.START })\r\n        return (\r\n          task\r\n          |> finalize(() => {\r\n            // task was canceled\r\n            if (!done) canceled = true\r\n\r\n            // clean up the worker\r\n            worker.postMessage({ status: TASK_STATUS.CANCEL })\r\n            idleWorker.push(worker)\r\n          })\r\n          |> mergeMap(async value => value) // allow for the finalize to run before the task if it was canceled\r\n          |> filter(() => !canceled) // if it was canceled, filter everything out\r\n          |> withLatestFrom(workerMessages) // switch the flow from having sent messages to receiving them\r\n          |> tap(([message]) => worker.postMessage(message))\r\n          |> pluck(1) // from here we only have messages from the worker\r\n          |> takeWhile(({ status }) => status !== TASK_STATUS.END)\r\n          |> tap(() => (done = true))\r\n          |> map(message => [\r\n            count,\r\n            message\r\n          ])\r\n        )\r\n      },\r\n      cpuCount\r\n    )\r\n\r\n  let taskCounter = 0\r\n  return messageObservable => {\r\n    const replay = new ReplaySubject()\r\n    const count = taskCounter\r\n    taskCounter++\r\n\r\n    const result =\r\n      (queue\r\n      |> filter(([_count]) => count === _count)\r\n      |> pluck(1))\r\n\r\n    result.subscribe(\r\n      v => replay.next(v),\r\n      err => replay.error(err),\r\n      () => replay.complete()\r\n    )\r\n\r\n    taskSubject.next(messageObservable)\r\n    return replay\r\n  }\r\n}\r\n","import { Observable, of } from 'rxjs'\r\nimport { takeUntil, publish, filter, map, mapTo, switchMap } from 'rxjs/operators'\r\n\r\nimport Parcel from '../parcel/index.ts'\r\nimport { PARCEL_REPORTER_EVENT } from '../parcel/index.ts'\r\nimport WorkerFarm from './workerFarm.ts'\r\nimport Task, { TASK_TYPE, TASK_STATUS } from './task.ts'\r\nimport AsyncObservable from '../utils/async-observable.ts'\r\n\r\nexport default (parcelOptions) =>\r\n  AsyncObservable(observer => {\r\n    const workerFarm = WorkerFarm()\r\n    const parcelBundle =\r\n      (Parcel(parcelOptions)\r\n      |> publish())\r\n        .refCount()\r\n  \r\n    const build =\r\n      parcelBundle\r\n      |> filter(({ name }) => name === PARCEL_REPORTER_EVENT.BUILD_START)\r\n  \r\n    const bundle =\r\n      parcelBundle\r\n\r\n    // const bundle =\r\n    //   build\r\n    //   |> switchMap(({ entryFiles, buildStartTime }) =>\r\n    //     parcelBundle\r\n    //     |> filter(({ name }) => name === PARCEL_REPORTER_EVENT.BUILD_SUCCESS)\r\n    //     |> map(bundle => ({ ...bundle, entryFiles, buildStartTime })))\r\n  \r\n    const test =\r\n      bundle\r\n      |> switchMap(bundle =>\r\n        of({ type: TASK_TYPE.ANALYZE })\r\n        |> workerFarm)\r\n\r\n    const result =\r\n      test\r\n\r\n    result.subscribe(observer)\r\n  \r\n    return () => {}\r\n  })\r\n","// import Parcel from '@parcel/core'\r\n\r\n// console.log(new Parcel())\r\n\r\nimport EPK from '../core/index.ts'\r\n\r\nconst run = (entryFiles) => {\r\n  const epk = EPK({\r\n    entryFiles\r\n  })\r\n\r\n  epk.subscribe(v => console.log(v))\r\n}\r\n\r\nrun()\r\n"],"names":["func","Observable","create","observer","unsubscribe","PARCEL_REPORTER_EVENT","initialParcelOptions","AsyncObservable","parcel","Parcel","entries","targets","test","distDir","sourceMaps","minify","scopeHoist","watch","err","build","throw","next","amount","globalThis","window","undefined","navigator","hardwareConcurrency","exec","command","childProcess","execSync","encoding","platform","os","output","parseInt","trim","split","EOL","map","line","filter","value","isNaN","reduce","sum","number","cores","cpus","cpu","index","hasHyperthreading","model","includes","isOdd","length","TASK_TYPE","TASK_STATUS","idleWorker","Array","cpuCount","fill","Worker","taskSubject","Subject","queue","mergeMap","task","_","count","worker","splice","workerMessages","fromEvent","done","canceled","postMessage","status","START","finalize","CANCEL","push","withLatestFrom","tap","message","pluck","takeWhile","END","taskCounter","messageObservable","replay","ReplaySubject","result","_count","subscribe","v","error","complete","parcelOptions","workerFarm","WorkerFarm","parcelBundle","publish","refCount","name","BUILD_START","bundle","switchMap","of","type","ANALYZE","run","entryFiles","epk","EPK","console","log"],"mappings":"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"}