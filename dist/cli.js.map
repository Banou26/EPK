{"version":3,"file":"cli.js","sources":["../src/utils/async-observable.ts","../src/parcel/index.ts","../src/utils/isBrowser.ts","../src/utils/cpu.ts","../src/core/task.ts","../src/workerFarm/browser.ts","../src/utils/tap.ts","../src/workerFarm/node.ts","../src/workerFarm/index.ts","../src/utils/emit.ts","../src/core/index.ts","../src/cli/index.ts"],"sourcesContent":["import { Observable } from 'rxjs'\n\nexport default <T>(func: Function): Observable<T> =>\n  Observable.create(observer => {\n    const unsubscribe = func(observer)\n    return async () => (await unsubscribe)?.()\n  })\n","import Parcel from '@parcel/core'\r\n\r\nimport AsyncObservable from '../utils/async-observable.ts'\r\n\r\nexport enum PARCEL_REPORTER_EVENT {\r\n  BUILD_START = 'buildStart',\r\n  BUILD_PROGRESS = 'buildProgress',\r\n  BUILD_SUCCESS = 'buildSuccess',\r\n  BUILD_FAILURE = 'buildFailure',\r\n  LOG = 'log'\r\n}\r\n\r\nexport default (initialParcelOptions) =>\r\n  AsyncObservable(async observer => {\r\n    const parcel = new Parcel({\r\n      entries: ['tests/unit/index_test.ts'],\r\n      targets: {\r\n        test: {\r\n          distDir: '.epk/dist/browser',\r\n          \"browsers\": [\"> 1%\", \"not dead\"]\r\n        }\r\n      },\r\n      sourceMaps: true,\r\n      minify: true,\r\n      scopeHoist: true\r\n    })\r\n    \r\n    const { unsubscribe } = await parcel.watch((err, build) => {\r\n      if (err) observer.throw(err)\r\n      observer.next(build)\r\n    })\r\n\r\n    return () => unsubscribe()\r\n  })\r\n","export default typeof window !== 'undefined'","import os from 'os'\r\nimport childProcess from 'child_process'\r\n\r\n// todo: once top level await gets there, use it\r\n\r\nlet amount\r\n\r\nif (globalThis.window !== undefined) {\r\n  amount = window.navigator.hardwareConcurrency\r\n} else {\r\n  const exec =\r\n    command =>\r\n      childProcess.execSync(command, {encoding: 'utf8'})\r\n  const platform = os.platform()\r\n\r\n  if (platform === 'linux') {\r\n    const output = exec('lscpu -p | egrep -v \"^#\" | sort -u -t, -k 2,4 | wc -l')\r\n    amount = parseInt(output.trim(), 10)\r\n  } else if (platform === 'darwin') {\r\n    const output = exec('sysctl -n hw.physicalcpu_max')\r\n    amount = parseInt(output.trim(), 10)\r\n  } else if (platform === 'windows') {\r\n    const output = exec('WMIC CPU Get NumberOfCores')\r\n    amount = output.split(os.EOL)\r\n      .map(line => parseInt(line))\r\n      .filter(value => !isNaN(value))\r\n      .reduce((sum, number) => sum + number, 0)\r\n  } else {\r\n    const cores = os.cpus().filter(function (cpu, index) {\r\n      const hasHyperthreading = cpu.model.includes('Intel')\r\n      const isOdd = index % 2 === 1\r\n      return !hasHyperthreading || isOdd\r\n    })\r\n    amount = cores.length\r\n  }\r\n}\r\n\r\n\r\n\r\nexport {\r\n  amount as cpuCount\r\n}","import { Observable } from 'rxjs'\r\n\r\nexport enum TASK_TYPE {\r\n  PRE_ANALYZE = 'preAnalyze',\r\n  RUN = 'run',\r\n  ANALYZE = 'analyze'\r\n}\r\n\r\nexport enum TASK_STATUS {\r\n  START = 'start',\r\n  READY = 'ready',\r\n  END = 'end',\r\n  CANCEL = 'cancel'\r\n}\r\n\r\nexport interface Task {\r\n  type: TASK_TYPE\r\n  data: any\r\n}\r\n\r\nexport interface TaskMessage {\r\n  type: TASK_TYPE\r\n  status: TASK_STATUS\r\n  data?: any\r\n}\r\n\r\n// export default\r\n//   (task: Task) =>\r\n//     messages =>\r\n//       messages\r\n//       |> \r\n\r\n\r\n// export default (task: Task) =>\r\n//   Observable.create(observer => {\r\n//     let _observer\r\n//     const task = Observable.create<TaskMessage>(observer => {\r\n//       _observer = observer\r\n//       observer.next({ type: TASK_STATUS.START })\r\n//       return () => observer.next({ type: TASK_STATUS.CANCEL })\r\n//     })\r\n//     workerFarm.next(task)\r\n//     return () => _observer.complete()\r\n//   })\r\n","import { Worker } from 'worker_threads'\r\n\r\nimport Logger from '@parcel/logger'\r\nimport { Observable, Subject, fromEvent, ReplaySubject } from 'rxjs'\r\nimport { mergeMap, tap, pluck, map, filter, finalize, shareReplay, publish, withLatestFrom, takeUntil, takeWhile, combineLatest } from 'rxjs/operators'\r\n\r\nimport { cpuCount } from '../utils/cpu.ts'\r\nimport { TaskMessage, TASK_STATUS } from '../core/task.ts'\r\n\r\nexport default () => {\r\n  const idleWorker =\r\n      Array(cpuCount)\r\n      .fill(undefined)\r\n      .map(() => new Worker('./dist/worker.js'))\r\n  const taskSubject = new Subject()\r\n\r\n  const queue =\r\n    taskSubject\r\n    |> mergeMap(\r\n      (task, _, count) => {\r\n        const worker = idleWorker.splice(0, 1)[0]\r\n        const workerMessages = fromEvent(worker, 'message')\r\n        let done = false\r\n        let canceled = false\r\n\r\n        worker.postMessage({ status: TASK_STATUS.START })\r\n        return (\r\n          task\r\n          |> finalize(() => {\r\n            if (!done) canceled = true\r\n            if (canceled) worker.postMessage({ status: TASK_STATUS.CANCEL })\r\n            idleWorker.push(worker)\r\n          })\r\n          |> mergeMap(async value => value) // allow for the finalize to run before the task if it was canceled\r\n          |> filter(() => !canceled) // if it was canceled, filter everything out\r\n          |> tap(message => worker.postMessage(message))\r\n          |> combineLatest(workerMessages, (_, message) => message) // switch the flow from having sent messages to receiving them\r\n          |> tap(({ status }) =>\r\n            status === TASK_STATUS.END\r\n              ? (done = true)\r\n              : undefined\r\n          )\r\n          |> takeWhile(({ status }) => status !== TASK_STATUS.END)\r\n          |> map(message => [\r\n            count,\r\n            message\r\n          ])\r\n        )\r\n      },\r\n      cpuCount\r\n    )\r\n\r\n  let taskCounter = 0\r\n  return messageObservable => {\r\n    const replay = new ReplaySubject()\r\n    const count = taskCounter\r\n    taskCounter++\r\n\r\n    const result =\r\n      (queue\r\n      |> filter(([_count]) => count === _count)\r\n      |> pluck(1))\r\n\r\n    result.subscribe(replay)\r\n\r\n    taskSubject.next(messageObservable)\r\n    return replay\r\n  }\r\n}\r\n","import { tap } from 'rxjs/operators'\r\nimport { isObservable } from 'rxjs'\r\n\r\nexport default (...args) =>\r\n  isObservable(args[0])\r\n    ? tap(value => args[0](value).subscribe())\r\n    : tap(...args)\r\n","import { Worker } from 'worker_threads'\r\n\r\nimport { Observable, Subject, fromEvent, ReplaySubject, of } from 'rxjs'\r\nimport { mergeMap, pluck, map, filter, finalize, shareReplay, publish, withLatestFrom, takeUntil, takeWhile, combineLatest, first } from 'rxjs/operators'\r\n\r\nimport { cpuCount } from '../utils/cpu.ts'\r\nimport { TaskMessage, TASK_STATUS } from '../core/task.ts'\r\nimport tap from '../utils/tap.ts'\r\n\r\nexport default (taskSubject) => {\r\n  const idleWorker =\r\n      Array(cpuCount)\r\n      .fill(undefined)\r\n      .map(() => new Worker('./dist/worker.js'))\r\n\r\n    return (\r\n      taskSubject\r\n      |> mergeMap(\r\n        (task, id) => {\r\n          const worker = idleWorker.splice(0, 1)[0]\r\n          const workerMessages = fromEvent(worker, 'message')\r\n          let done = false\r\n          let canceled = false\r\n\r\n          return (\r\n            task\r\n            |> tap(message =>\r\n              of(message)\r\n              |> first()\r\n              |> tap(message =>\r\n                worker.postMessage({ id, status: TASK_STATUS.START, ...message })\r\n              )\r\n            )\r\n            |> finalize(() => {\r\n              if (!done) canceled = true\r\n              if (canceled) worker.postMessage({ id, status: TASK_STATUS.CANCEL })\r\n              idleWorker.push(worker)\r\n            })\r\n            |> mergeMap(async message => message) // allow for the finalize to run before the task if it was canceled\r\n            |> filter(() => !canceled) // if it was canceled, filter everything out\r\n            |> tap(message => worker.postMessage({ id, ...message }))\r\n            |> combineLatest(workerMessages, (_, task) => task) // switch the flow from having sent messages to receiving them\r\n            |> tap(({ status }) => status === TASK_STATUS.END && (done = true))\r\n            |> takeWhile(({ status }) => status !== TASK_STATUS.END)\r\n            |> map(message => [id, message])\r\n          )\r\n        },\r\n        cpuCount\r\n      )\r\n    )\r\n}\r\n","import { Observable, Subject, ReplaySubject } from 'rxjs'\r\nimport { pluck, filter } from 'rxjs/operators'\r\n\r\nimport isBrowser from '../utils/isBrowser.ts'\r\nimport browserWorkerFarm from './browser.ts'\r\nimport nodeWorkerFarm from './node.ts'\r\n\r\nexport default () => {\r\n  const taskSubject = new Subject()\r\n\r\n  const queue =\r\n    isBrowser\r\n      ? browserWorkerFarm(taskSubject)\r\n      : nodeWorkerFarm(taskSubject)\r\n\r\n  let idCounter = 0\r\n  return messageObservable => {\r\n    const replay = new ReplaySubject()\r\n    const id = idCounter\r\n    idCounter++\r\n\r\n    const result =\r\n      (queue\r\n      |> filter(([_id]) => _id === id)\r\n      |> pluck(1))\r\n\r\n    result.subscribe(replay)\r\n\r\n    taskSubject.next(messageObservable)\r\n    return replay\r\n  }\r\n}\r\n","import { Observable } from 'rxjs';\r\n\r\nexport default value =>\r\n  Observable.create(observer => observer.next(value))","import { Observable, of, generate } from 'rxjs'\r\nimport { takeUntil, publish, filter, map, mapTo, switchMap } from 'rxjs/operators'\r\n\r\nimport Parcel from '../parcel/index.ts'\r\nimport { PARCEL_REPORTER_EVENT } from '../parcel/index.ts'\r\nimport WorkerFarm from '../workerFarm/index.ts'\r\nimport Task, { TASK_TYPE, TASK_STATUS } from './task.ts'\r\nimport emit from '../utils/emit.ts'\r\nimport AsyncObservable from '../utils/async-observable.ts'\r\n\r\nexport default (parcelOptions) =>\r\n  AsyncObservable(observer => {\r\n    const workerFarm = WorkerFarm()\r\n    const parcelBundle =\r\n      (Parcel(parcelOptions)\r\n      |> publish())\r\n        .refCount()\r\n  \r\n    const bundle =\r\n      parcelBundle\r\n      |> map(bundle => ({ bundle, parcelOptions }))\r\n\r\n    const test =\r\n      bundle\r\n      |> switchMap(bundle =>\r\n        emit({ type: TASK_TYPE.ANALYZE })\r\n        |> workerFarm)\r\n\r\n    const result =\r\n      test\r\n\r\n    result.subscribe(observer)\r\n  \r\n    return () => {}\r\n  })\r\n","// import Parcel from '@parcel/core'\r\n\r\n// console.log(new Parcel())\r\n\r\nimport EPK from '../core/index.ts'\r\n\r\nconst run = (entryFiles) => {\r\n  const epk = EPK({\r\n    entryFiles\r\n  })\r\n\r\n  epk.subscribe(v => console.log(v))\r\n}\r\n\r\nrun()\r\n"],"names":["func","Observable","create","observer","unsubscribe","PARCEL_REPORTER_EVENT","initialParcelOptions","AsyncObservable","parcel","Parcel","entries","targets","test","distDir","sourceMaps","minify","scopeHoist","watch","err","build","throw","next","window","amount","globalThis","undefined","navigator","hardwareConcurrency","exec","command","childProcess","execSync","encoding","platform","os","output","parseInt","trim","split","EOL","map","line","filter","value","isNaN","reduce","sum","number","cores","cpus","cpu","index","hasHyperthreading","model","includes","isOdd","length","TASK_TYPE","TASK_STATUS","idleWorker","Array","cpuCount","fill","Worker","taskSubject","Subject","queue","mergeMap","task","_","count","worker","splice","workerMessages","fromEvent","done","canceled","postMessage","status","START","finalize","CANCEL","push","tap","message","combineLatest","END","takeWhile","taskCounter","messageObservable","replay","ReplaySubject","result","_count","pluck","subscribe","args","isObservable","id","of","first","isBrowser","browserWorkerFarm","nodeWorkerFarm","idCounter","_id","parcelOptions","workerFarm","WorkerFarm","parcelBundle","publish","refCount","bundle","switchMap","emit","type","ANALYZE","run","entryFiles","epk","EPK","v","console","log"],"mappings":"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"}